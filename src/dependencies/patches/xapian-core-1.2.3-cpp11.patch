diff -crB xapian-core-1.2.3/api/replication.cc xapian-core-1.2.3-edited/api/replication.cc
*** xapian-core-1.2.3/api/replication.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/api/replication.cc	2014-05-18 11:24:27.000000000 +0200
***************
*** 56,62 ****
  
  // The banner comment used at the top of the replica's stub database file.
  #define REPLICA_STUB_BANNER \
! "# Automatically generated by Xapian::DatabaseReplica v"XAPIAN_VERSION".\n" \
  "# Do not manually edit - replication operations may regenerate this file.\n"
  
  void
--- 56,62 ----
  
  // The banner comment used at the top of the replica's stub database file.
  #define REPLICA_STUB_BANNER \
! "# Automatically generated by Xapian::DatabaseReplica v" XAPIAN_VERSION ".\n" \
  "# Do not manually edit - replication operations may regenerate this file.\n"
  
  void
diff -crB xapian-core-1.2.3/backends/chert/chert_database.cc xapian-core-1.2.3-edited/backends/chert/chert_database.cc
*** xapian-core-1.2.3/backends/chert/chert_database.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/chert/chert_database.cc	2014-05-18 11:24:27.000000000 +0200
***************
*** 1162,1168 ****
  
  		string tname = *term;
  		if (tname.size() > MAX_SAFE_TERM_LENGTH)
! 		    throw Xapian::InvalidArgumentError("Term too long (> "STRINGIZE(MAX_SAFE_TERM_LENGTH)"): " + tname);
  		add_freq_delta(tname, 1, wdf);
  		insert_mod_plist(did, tname, wdf);
  
--- 1162,1168 ----
  
  		string tname = *term;
  		if (tname.size() > MAX_SAFE_TERM_LENGTH)
! 		    throw Xapian::InvalidArgumentError("Term too long (> " STRINGIZE(MAX_SAFE_TERM_LENGTH) "): " + tname);
  		add_freq_delta(tname, 1, wdf);
  		insert_mod_plist(did, tname, wdf);
  
***************
*** 1363,1369 ****
  		    new_doclen += new_wdf;
  		    stats.check_wdf(new_wdf);
  		    if (new_tname.size() > MAX_SAFE_TERM_LENGTH)
! 			throw Xapian::InvalidArgumentError("Term too long (> "STRINGIZE(MAX_SAFE_TERM_LENGTH)"): " + new_tname);
  		    add_freq_delta(new_tname, 1, new_wdf);
  		    update_mod_plist(did, new_tname, 'A', new_wdf);
  		    PositionIterator pos = term.positionlist_begin();
--- 1363,1369 ----
  		    new_doclen += new_wdf;
  		    stats.check_wdf(new_wdf);
  		    if (new_tname.size() > MAX_SAFE_TERM_LENGTH)
! 			throw Xapian::InvalidArgumentError("Term too long (> " STRINGIZE(MAX_SAFE_TERM_LENGTH) "): " + new_tname);
  		    add_freq_delta(new_tname, 1, new_wdf);
  		    update_mod_plist(did, new_tname, 'A', new_wdf);
  		    PositionIterator pos = term.positionlist_begin();
diff -crB xapian-core-1.2.3/backends/chert/chert_table.cc xapian-core-1.2.3-edited/backends/chert/chert_table.cc
*** xapian-core-1.2.3/backends/chert/chert_table.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/chert/chert_table.cc	2014-05-18 11:24:27.000000000 +0200
***************
*** 567,573 ****
      /* check level overflow - this isn't something that should ever happen
       * but deserves more than an Assert()... */
      if (level == BTREE_CURSOR_LEVELS) {
! 	throw Xapian::DatabaseCorruptError("Btree has grown impossibly large ("STRINGIZE(BTREE_CURSOR_LEVELS)" levels)");
      }
  
      byte * q = zeroed_new(block_size);
--- 567,573 ----
      /* check level overflow - this isn't something that should ever happen
       * but deserves more than an Assert()... */
      if (level == BTREE_CURSOR_LEVELS) {
! 	throw Xapian::DatabaseCorruptError("Btree has grown impossibly large (" STRINGIZE(BTREE_CURSOR_LEVELS) " levels)");
      }
  
      byte * q = zeroed_new(block_size);
diff -crB xapian-core-1.2.3/backends/chert/chert_version.cc xapian-core-1.2.3-edited/backends/chert/chert_version.cc
*** xapian-core-1.2.3/backends/chert/chert_version.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/chert/chert_version.cc	2014-05-18 11:24:28.000000000 +0200
***************
*** 139,145 ****
  	string msg = filename;
  	msg += ": Chert version file is version ";
  	msg += str(version);
! 	msg += " but I only understand "STRINGIZE(CHERT_VERSION);
  	throw Xapian::DatabaseVersionError(msg);
      }
  
--- 139,145 ----
  	string msg = filename;
  	msg += ": Chert version file is version ";
  	msg += str(version);
! 	msg += " but I only understand " STRINGIZE(CHERT_VERSION);
  	throw Xapian::DatabaseVersionError(msg);
      }
  
diff -crB xapian-core-1.2.3/backends/flint/flint_database.cc xapian-core-1.2.3-edited/backends/flint/flint_database.cc
*** xapian-core-1.2.3/backends/flint/flint_database.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/flint/flint_database.cc	2014-05-18 11:24:28.000000000 +0200
***************
*** 1150,1156 ****
  
  		string tname = *term;
  		if (tname.size() > MAX_SAFE_TERM_LENGTH)
! 		    throw Xapian::InvalidArgumentError("Term too long (> "STRINGIZE(MAX_SAFE_TERM_LENGTH)"): " + tname);
  		add_freq_delta(tname, 1, wdf);
  		insert_mod_plist(did, tname, wdf);
  
--- 1150,1156 ----
  
  		string tname = *term;
  		if (tname.size() > MAX_SAFE_TERM_LENGTH)
! 		    throw Xapian::InvalidArgumentError("Term too long (> " STRINGIZE(MAX_SAFE_TERM_LENGTH) "): " + tname);
  		add_freq_delta(tname, 1, wdf);
  		insert_mod_plist(did, tname, wdf);
  
***************
*** 1297,1303 ****
  		modify_shortcut_docid = 0;
  	    }
  	}
!   
  	if (!modifying || document.internal->terms_modified()) {
  	    Xapian::Internal::RefCntPtr<const FlintWritableDatabase> ptrtothis(this);
  	    FlintTermList termlist(ptrtothis, did);
--- 1297,1303 ----
  		modify_shortcut_docid = 0;
  	    }
  	}
! 
  	if (!modifying || document.internal->terms_modified()) {
  	    Xapian::Internal::RefCntPtr<const FlintWritableDatabase> ptrtothis(this);
  	    FlintTermList termlist(ptrtothis, did);
***************
*** 1316,1322 ****
  	    term = document.termlist_begin();
  	    flint_doclen_t old_doclen = termlist.get_doclength();
  	    string old_tname, new_tname;
!  
  	    total_length -= old_doclen;
  
  	    termlist.next();
--- 1316,1322 ----
  	    term = document.termlist_begin();
  	    flint_doclen_t old_doclen = termlist.get_doclength();
  	    string old_tname, new_tname;
! 
  	    total_length -= old_doclen;
  
  	    termlist.next();
***************
*** 1345,1351 ****
  		    // Term new_tname as been added.
  		    termcount new_wdf = term.get_wdf();
  		    if (new_tname.size() > MAX_SAFE_TERM_LENGTH)
! 			throw Xapian::InvalidArgumentError("Term too long (> "STRINGIZE(MAX_SAFE_TERM_LENGTH)"): " + new_tname);
  		    add_freq_delta(new_tname, 1, new_wdf);
  		    update_mod_plist(did, new_tname, 'A', new_wdf);
  		    PositionIterator pos = term.positionlist_begin();
--- 1345,1351 ----
  		    // Term new_tname as been added.
  		    termcount new_wdf = term.get_wdf();
  		    if (new_tname.size() > MAX_SAFE_TERM_LENGTH)
! 			throw Xapian::InvalidArgumentError("Term too long (> " STRINGIZE(MAX_SAFE_TERM_LENGTH) "): " + new_tname);
  		    add_freq_delta(new_tname, 1, new_wdf);
  		    update_mod_plist(did, new_tname, 'A', new_wdf);
  		    PositionIterator pos = term.positionlist_begin();
diff -crB xapian-core-1.2.3/backends/flint/flint_table.cc xapian-core-1.2.3-edited/backends/flint/flint_table.cc
*** xapian-core-1.2.3/backends/flint/flint_table.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/flint/flint_table.cc	2014-05-18 11:24:28.000000000 +0200
***************
*** 570,576 ****
      /* check level overflow - this isn't something that should ever happen
       * but deserves more than an Assert()... */
      if (level == BTREE_CURSOR_LEVELS) {
! 	throw Xapian::DatabaseCorruptError("Btree has grown impossibly large ("STRINGIZE(BTREE_CURSOR_LEVELS)" levels)");
      }
  
      byte * q = zeroed_new(block_size);
--- 570,576 ----
      /* check level overflow - this isn't something that should ever happen
       * but deserves more than an Assert()... */
      if (level == BTREE_CURSOR_LEVELS) {
! 	throw Xapian::DatabaseCorruptError("Btree has grown impossibly large (" STRINGIZE(BTREE_CURSOR_LEVELS) " levels)");
      }
  
      byte * q = zeroed_new(block_size);
***************
*** 2137,2143 ****
  	    } else {
  		read_block(n, p);
  	    }
! 	    
  	    if (writable) AssertEq(revision_number, latest_revision_number);
  	    if (REVISION(p) > revision_number + writable) {
  		set_overwritten();
--- 2137,2143 ----
  	    } else {
  		read_block(n, p);
  	    }
! 
  	    if (writable) AssertEq(revision_number, latest_revision_number);
  	    if (REVISION(p) > revision_number + writable) {
  		set_overwritten();
diff -crB xapian-core-1.2.3/backends/flint/flint_version.cc xapian-core-1.2.3-edited/backends/flint/flint_version.cc
*** xapian-core-1.2.3/backends/flint/flint_version.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/flint/flint_version.cc	2014-05-18 11:24:28.000000000 +0200
***************
*** 119,125 ****
      if (size != VERSIONFILE_SIZE) {
  	string msg("Flint version file ");
  	msg += filename;
! 	msg += " should be "STRINGIZE(VERSIONFILE_SIZE)" bytes, actually ";
  	msg += str(size);
  	throw Xapian::DatabaseCorruptError(msg);
      }
--- 119,125 ----
      if (size != VERSIONFILE_SIZE) {
  	string msg("Flint version file ");
  	msg += filename;
! 	msg += " should be " STRINGIZE(VERSIONFILE_SIZE) " bytes, actually ";
  	msg += str(size);
  	throw Xapian::DatabaseCorruptError(msg);
      }
***************
*** 159,165 ****
  	msg += filename;
  	msg += " is version ";
  	msg += str(version);
! 	msg += " but I only understand "STRINGIZE(FLINT_VERSION);
  	throw Xapian::DatabaseVersionError(msg);
      }
  
--- 159,165 ----
  	msg += filename;
  	msg += " is version ";
  	msg += str(version);
! 	msg += " but I only understand " STRINGIZE(FLINT_VERSION);
  	throw Xapian::DatabaseVersionError(msg);
      }
  
diff -crB xapian-core-1.2.3/backends/remote/remote-database.cc xapian-core-1.2.3-edited/backends/remote/remote-database.cc
*** xapian-core-1.2.3/backends/remote/remote-database.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/backends/remote/remote-database.cc	2014-05-18 11:24:28.000000000 +0200
***************
*** 100,106 ****
  	errmsg += str(protocol_major);
  	errmsg += '.';
  	errmsg += str(protocol_minor);
! 	errmsg += " ("STRINGIZE(XAPIAN_REMOTE_PROTOCOL_MAJOR_VERSION)"."STRINGIZE(XAPIAN_REMOTE_PROTOCOL_MINOR_VERSION)" supported)";
  	throw Xapian::NetworkError(errmsg, context);
      }
  
--- 100,106 ----
  	errmsg += str(protocol_major);
  	errmsg += '.';
  	errmsg += str(protocol_minor);
! 	errmsg += " (" STRINGIZE(XAPIAN_REMOTE_PROTOCOL_MAJOR_VERSION) "." STRINGIZE(XAPIAN_REMOTE_PROTOCOL_MINOR_VERSION) " supported)";
  	throw Xapian::NetworkError(errmsg, context);
      }
  
diff -crB xapian-core-1.2.3/examples/copydatabase.cc xapian-core-1.2.3-edited/examples/copydatabase.cc
*** xapian-core-1.2.3/examples/copydatabase.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/examples/copydatabase.cc	2014-05-18 11:24:29.000000000 +0200
***************
*** 37,43 ****
  static void
  show_usage(int rc)
  {
!     cout << "Usage: "PROG_NAME" SOURCE_DATABASE... DESTINATION_DATABASE\n\n"
  "Options:\n"
  "  --help           display this help and exit\n"
  "  --version        output version information and exit" << endl;
--- 37,43 ----
  static void
  show_usage(int rc)
  {
!     cout << "Usage: " PROG_NAME " SOURCE_DATABASE... DESTINATION_DATABASE\n\n"
  "Options:\n"
  "  --help           display this help and exit\n"
  "  --version        output version information and exit" << endl;
***************
*** 49,59 ****
  try {
      if (argc > 1 && argv[1][0] == '-') {
  	if (strcmp(argv[1], "--help") == 0) {
! 	    cout << PROG_NAME" - "PROG_DESC"\n\n";
  	    show_usage(0);
  	}
  	if (strcmp(argv[1], "--version") == 0) {
! 	    cout << PROG_NAME" - "PACKAGE_STRING << endl;
  	    exit(0);
  	}
      }
--- 49,59 ----
  try {
      if (argc > 1 && argv[1][0] == '-') {
  	if (strcmp(argv[1], "--help") == 0) {
! 	    cout << PROG_NAME " - " PROG_DESC"\n\n";
  	    show_usage(0);
  	}
  	if (strcmp(argv[1], "--version") == 0) {
! 	    cout << PROG_NAME " - " PACKAGE_STRING << endl;
  	    exit(0);
  	}
      }
diff -crB xapian-core-1.2.3/examples/delve.cc xapian-core-1.2.3-edited/examples/delve.cc
*** xapian-core-1.2.3/examples/delve.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/examples/delve.cc	2014-05-18 11:24:29.000000000 +0200
***************
*** 47,53 ****
  #define PROG_DESC "Inspect the contents of a Xapian database"
  
  static void show_usage() {
!     cout << "Usage: "PROG_NAME" [OPTIONS] DATABASE...\n\n"
  "Options:\n"
  "  -a                    show all terms in the database\n"
  "  -r <recno>            for term list(s)\n"
--- 47,53 ----
  #define PROG_DESC "Inspect the contents of a Xapian database"
  
  static void show_usage() {
!     cout << "Usage: " PROG_NAME " [OPTIONS] DATABASE...\n\n"
  "Options:\n"
  "  -a                    show all terms in the database\n"
  "  -r <recno>            for term list(s)\n"
***************
*** 194,205 ****
  main(int argc, char **argv) try {
      if (argc > 1 && argv[1][0] == '-') {
  	if (strcmp(argv[1], "--help") == 0) {
! 	    cout << PROG_NAME" - "PROG_DESC"\n\n";
  	    show_usage();
  	    exit(0);
  	}
  	if (strcmp(argv[1], "--version") == 0) {
! 	    cout << PROG_NAME" - "PACKAGE_STRING << endl;
  	    exit(0);
  	}
      }
--- 194,205 ----
  main(int argc, char **argv) try {
      if (argc > 1 && argv[1][0] == '-') {
  	if (strcmp(argv[1], "--help") == 0) {
! 	    cout << PROG_NAME " - " PROG_DESC"\n\n";
  	    show_usage();
  	    exit(0);
  	}
  	if (strcmp(argv[1], "--version") == 0) {
! 	    cout << PROG_NAME " - " PACKAGE_STRING << endl;
  	    exit(0);
  	}
      }
diff -crB xapian-core-1.2.3/examples/quest.cc xapian-core-1.2.3-edited/examples/quest.cc
*** xapian-core-1.2.3/examples/quest.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/examples/quest.cc	2014-05-18 11:24:29.000000000 +0200
***************
*** 47,53 ****
  };
  
  static void show_usage() {
!     cout << "Usage: "PROG_NAME" [OPTIONS] 'QUERY'\n"
  "NB: QUERY should be quoted to protect it from the shell.\n\n"
  "Options:\n"
  "  -d, --db=DIRECTORY  database to search (multiple databases may be specified)\n"
--- 47,53 ----
  };
  
  static void show_usage() {
!     cout << "Usage: " PROG_NAME " [OPTIONS] 'QUERY'\n"
  "NB: QUERY should be quoted to protect it from the shell.\n\n"
  "Options:\n"
  "  -d, --db=DIRECTORY  database to search (multiple databases may be specified)\n"
***************
*** 101,110 ****
  		}
  		break;
  	    case 'v':
! 		cout << PROG_NAME" - "PACKAGE_STRING << endl;
  		exit(0);
  	    case 'h':
! 		cout << PROG_NAME" - "PROG_DESC"\n\n";
  		show_usage();
  		exit(0);
  	    case ':': // missing parameter
--- 101,110 ----
  		}
  		break;
  	    case 'v':
! 		cout << PROG_NAME " - " PACKAGE_STRING << endl;
  		exit(0);
  	    case 'h':
! 		cout << PROG_NAME " - " PROG_DESC"\n\n";
  		show_usage();
  		exit(0);
  	    case ':': // missing parameter
diff -crB xapian-core-1.2.3/examples/xapian-metadata.cc xapian-core-1.2.3-edited/examples/xapian-metadata.cc
*** xapian-core-1.2.3/examples/xapian-metadata.cc	2010-08-24 09:50:23.000000000 +0200
--- xapian-core-1.2.3-edited/examples/xapian-metadata.cc	2014-05-18 11:24:29.000000000 +0200
***************
*** 34,41 ****
  #define PROG_DESC "Read and write user metadata"
  
  static void show_usage() {
!     cout << "Usage: "PROG_NAME" get PATH_TO_DATABASE KEY\n"
! 	    "       "PROG_NAME" set PATH_TO_DATABASE KEY VALUE" << endl;
  }
  
  int
--- 34,41 ----
  #define PROG_DESC "Read and write user metadata"
  
  static void show_usage() {
!     cout << "Usage: " PROG_NAME " get PATH_TO_DATABASE KEY\n"
! 	    "       " PROG_NAME " set PATH_TO_DATABASE KEY VALUE" << endl;
  }
  
  int
***************
*** 50,61 ****
  
      if (command[0] == '-') {
  	if (strcmp(command, "--help") == 0) {
! 	    cout << PROG_NAME" - "PROG_DESC"\n\n";
  	    show_usage();
  	    exit(0);
  	}
  	if (strcmp(command, "--version") == 0) {
! 	    cout << PROG_NAME" - "PACKAGE_STRING << endl;
  	    exit(0);
  	}
      }
--- 50,61 ----
  
      if (command[0] == '-') {
  	if (strcmp(command, "--help") == 0) {
! 	    cout << PROG_NAME " - " PROG_DESC"\n\n";
  	    show_usage();
  	    exit(0);
  	}
  	if (strcmp(command, "--version") == 0) {
! 	    cout << PROG_NAME " - " PACKAGE_STRING << endl;
  	    exit(0);
  	}
      }
diff -crB xapian-core-1.2.3/queryparser/queryparser_internal.cc xapian-core-1.2.3-edited/queryparser/queryparser_internal.cc
*** xapian-core-1.2.3/queryparser/queryparser_internal.cc	2010-08-24 09:58:25.000000000 +0200
--- xapian-core-1.2.3-edited/queryparser/queryparser_internal.cc	2014-05-18 11:24:29.000000000 +0200
***************
*** 1521,1527 ****
  #define BOOL_OP_TO_QUERY(E, A, OP, B, OP_TXT) \
      do {\
  	if (!A || !B) {\
! 	    state->error = "Syntax: <expression> "OP_TXT" <expression>";\
  	    yy_parse_failed(yypParser);\
  	    return;\
  	}\
--- 1521,1527 ----
  #define BOOL_OP_TO_QUERY(E, A, OP, B, OP_TXT) \
      do {\
  	if (!A || !B) {\
! 	    state->error = "Syntax: <expression> " OP_TXT " <expression>";\
  	    yy_parse_failed(yypParser);\
  	    return;\
  	}\
***************
*** 1534,1543 ****
  /* Next is all token values, in a form suitable for use by makeheaders.
  ** This section will be null unless lemon is run with the -m switch.
  */
! /* 
  ** These constants (all generated automatically by the parser generator)
  ** specify the various kinds of tokens (terminals) that the parser
! ** understands. 
  **
  ** Each symbol here is a terminal symbol in the grammar.
  */
--- 1534,1543 ----
  /* Next is all token values, in a form suitable for use by makeheaders.
  ** This section will be null unless lemon is run with the -m switch.
  */
! /*
  ** These constants (all generated automatically by the parser generator)
  ** specify the various kinds of tokens (terminals) that the parser
! ** understands.
  **
  ** Each symbol here is a terminal symbol in the grammar.
  */
***************
*** 1554,1560 ****
  **                       and nonterminals.  "int" is used otherwise.
  **    YYNOCODE           is a number of type YYCODETYPE which corresponds
  **                       to no legal terminal or nonterminal number.  This
! **                       number is used to fill in empty slots of the hash 
  **                       table.
  **    YYFALLBACK         If defined, this indicates that one or more tokens
  **                       have fall-back values which should be used if the
--- 1554,1560 ----
  **                       and nonterminals.  "int" is used otherwise.
  **    YYNOCODE           is a number of type YYCODETYPE which corresponds
  **                       to no legal terminal or nonterminal number.  This
! **                       number is used to fill in empty slots of the hash
  **                       table.
  **    YYFALLBACK         If defined, this indicates that one or more tokens
  **                       have fall-back values which should be used if the
***************
*** 1563,1569 ****
  **                       and nonterminal numbers.  "unsigned char" is
  **                       used if there are fewer than 250 rules and
  **                       states combined.  "int" is used otherwise.
! **    ParseTOKENTYPE     is the data type used for minor tokens given 
  **                       directly to the parser from the tokenizer.
  **    YYMINORTYPE        is the data type used for all minor tokens.
  **                       This is typically a union of many types, one of
--- 1563,1569 ----
  **                       and nonterminal numbers.  "unsigned char" is
  **                       used if there are fewer than 250 rules and
  **                       states combined.  "int" is used otherwise.
! **    ParseTOKENTYPE     is the data type used for minor tokens given
  **                       directly to the parser from the tokenizer.
  **    YYMINORTYPE        is the data type used for all minor tokens.
  **                       This is typically a union of many types, one of
***************
*** 1621,1627 ****
  /* Next are the tables used to determine what action to take based on the
  ** current state and lookahead token.  These tables are used to implement
  ** functions that take a state number and lookahead value and return an
! ** action integer.  
  **
  ** Suppose the action integer is N.  Then the action is determined as
  ** follows
--- 1621,1627 ----
  /* Next are the tables used to determine what action to take based on the
  ** current state and lookahead token.  These tables are used to implement
  ** functions that take a state number and lookahead value and return an
! ** action integer.
  **
  ** Suppose the action integer is N.  Then the action is determined as
  ** follows
***************
*** 1646,1652 ****
  ** If the index value yy_shift_ofst[S]+X is out of range or if the value
  ** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
  ** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
! ** and that yy_default[S] should be used instead.  
  **
  ** The formula above is for computing the action when the lookahead is
  ** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
--- 1646,1652 ----
  ** If the index value yy_shift_ofst[S]+X is out of range or if the value
  ** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
  ** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
! ** and that yy_default[S] should be used instead.
  **
  ** The formula above is for computing the action when the lookahead is
  ** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
***************
*** 1761,1767 ****
  
  /* The next table maps tokens into fallback tokens.  If a construct
  ** like the following:
! ** 
  **      %fallback ID X Y Z.
  **
  ** appears in the grammar, then ID becomes a fallback token for X, Y,
--- 1761,1767 ----
  
  /* The next table maps tokens into fallback tokens.  If a construct
  ** like the following:
! **
  **      %fallback ID X Y Z.
  **
  ** appears in the grammar, then ID becomes a fallback token for X, Y,
***************
*** 1819,1834 ****
  /* For tracing shifts, the names of all terminals and nonterminals
  ** are required.  The following table supplies these names */
  static const char *const yyTokenName[] = {
!   "$",             "ERROR",         "OR",            "XOR",         
!   "AND",           "NOT",           "NEAR",          "ADJ",         
!   "LOVE",          "HATE",          "HATE_AFTER_AND",  "SYNONYM",     
!   "TERM",          "GROUP_TERM",    "PHR_TERM",      "WILD_TERM",   
!   "PARTIAL_TERM",  "BOOLEAN_FILTER",  "RANGE",         "QUOTE",       
!   "BRA",           "KET",           "EMPTY_GROUP_OK",  "error",       
!   "query",         "expr",          "prob_expr",     "bool_arg",    
!   "prob",          "term",          "stop_prob",     "stop_term",   
!   "compound_term",  "phrase",        "phrased_term",  "group",       
!   "near_expr",     "adj_expr",    
  };
  
  /* For tracing reduce actions, the names of all rules are required.
--- 1819,1834 ----
  /* For tracing shifts, the names of all terminals and nonterminals
  ** are required.  The following table supplies these names */
  static const char *const yyTokenName[] = {
!   "$",             "ERROR",         "OR",            "XOR",
!   "AND",           "NOT",           "NEAR",          "ADJ",
!   "LOVE",          "HATE",          "HATE_AFTER_AND",  "SYNONYM",
!   "TERM",          "GROUP_TERM",    "PHR_TERM",      "WILD_TERM",
!   "PARTIAL_TERM",  "BOOLEAN_FILTER",  "RANGE",         "QUOTE",
!   "BRA",           "KET",           "EMPTY_GROUP_OK",  "error",
!   "query",         "expr",          "prob_expr",     "bool_arg",
!   "prob",          "term",          "stop_prob",     "stop_term",
!   "compound_term",  "phrase",        "phrased_term",  "group",
!   "near_expr",     "adj_expr",
  };
  
  /* For tracing reduce actions, the names of all rules are required.
***************
*** 1912,1918 ****
  }
  #endif /* XAPIAN_DEBUG_LOG */
  
! /* 
  ** This function allocates a new parser.
  ** The only argument is a pointer to a function which works like
  ** malloc.
--- 1912,1918 ----
  }
  #endif /* XAPIAN_DEBUG_LOG */
  
! /*
  ** This function allocates a new parser.
  ** The only argument is a pointer to a function which works like
  ** malloc.
***************
*** 1943,1949 ****
      /* Here is inserted the actions which take place when a
      ** terminal or non-terminal is destroyed.  This can happen
      ** when the symbol is popped from the stack during a
!     ** reduce or during error processing or when a parser is 
      ** being destroyed before it is finished parsing.
      **
      ** Note: during a reduce, the only symbols destroyed are those
--- 1943,1949 ----
      /* Here is inserted the actions which take place when a
      ** terminal or non-terminal is destroyed.  This can happen
      ** when the symbol is popped from the stack during a
!     ** reduce or during error processing or when a parser is
      ** being destroyed before it is finished parsing.
      **
      ** Note: during a reduce, the only symbols destroyed are those
***************
*** 2041,2047 ****
    return yymajor;
  }
  
! /* 
  ** Deallocate and destroy a parser.  Destructors are all called for
  ** all stack elements before shutting the parser down.
  **
--- 2041,2047 ----
    return yymajor;
  }
  
! /*
  ** Deallocate and destroy a parser.  Destructors are all called for
  ** all stack elements before shutting the parser down.
  **
***************
*** 2071,2077 ****
  ){
    int i;
    int stateno = pParser->yystack.back().stateno;
!  
    if( stateno>YY_SHIFT_MAX || (i = yy_shift_ofst[stateno])==YY_SHIFT_USE_DFLT ){
      return yy_default[stateno];
    }
--- 2071,2077 ----
  ){
    int i;
    int stateno = pParser->yystack.back().stateno;
! 
    if( stateno>YY_SHIFT_MAX || (i = yy_shift_ofst[stateno])==YY_SHIFT_USE_DFLT ){
      return yy_default[stateno];
    }
***************
*** 2259,2265 ****
    ** not set the value of its left-hand side nonterminal.  Leaving the
    ** value of the nonterminal uninitialized is utterly harmless as long
    ** as the value is never used.  So really the only thing this code
!   ** accomplishes is to quieten purify.  
    **
    ** 2007-01-16:  The wireshark project (www.wireshark.org) reports that
    ** without this code, their parser segfaults.  I'm not sure what there
--- 2259,2265 ----
    ** not set the value of its left-hand side nonterminal.  Leaving the
    ** value of the nonterminal uninitialized is utterly harmless as long
    ** as the value is never used.  So really the only thing this code
!   ** accomplishes is to quieten purify.
    **
    ** 2007-01-16:  The wireshark project (www.wireshark.org) reports that
    ** without this code, their parser segfaults.  I'm not sure what there
***************
*** 2870,2876 ****
  #ifdef YYERRORSYMBOL
        /* A syntax error has occurred.
        ** The response to an error depends upon whether or not the
!       ** grammar defines an error token "ERROR".  
        **
        ** This is what we do if the grammar does define ERROR:
        **
--- 2870,2876 ----
  #ifdef YYERRORSYMBOL
        /* A syntax error has occurred.
        ** The response to an error depends upon whether or not the
!       ** grammar defines an error token "ERROR".
        **
        ** This is what we do if the grammar does define ERROR:
        **
***************
*** 2928,2934 ****
        yy_syntax_error(yypParser,yymajor,yyminorunion);
        yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
        yymajor = YYNOCODE;
!       
  #else  /* YYERRORSYMBOL is not defined */
        /* This is what we do if the grammar does not define ERROR:
        **
--- 2928,2934 ----
        yy_syntax_error(yypParser,yymajor,yyminorunion);
        yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
        yymajor = YYNOCODE;
! 
  #else  /* YYERRORSYMBOL is not defined */
        /* This is what we do if the grammar does not define ERROR:
        **
